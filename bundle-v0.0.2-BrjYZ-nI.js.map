{"version":3,"file":"bundle-v0.0.2-BrjYZ-nI.js","sources":["../node_modules/svelte/src/runtime/internal/utils.js","../node_modules/svelte/src/runtime/internal/dom.js","../node_modules/svelte/src/runtime/internal/lifecycle.js","../node_modules/svelte/src/runtime/internal/scheduler.js","../node_modules/svelte/src/runtime/internal/transitions.js","../node_modules/svelte/src/runtime/internal/each.js","../node_modules/svelte/src/runtime/internal/spread.js","../node_modules/svelte/src/runtime/internal/Component.js","../node_modules/svelte/src/runtime/internal/disclose-version/index.js","../node_modules/svelte/src/shared/version.js","../node_modules/style-inject/dist/style-inject.es.js","../node_modules/svelte/src/runtime/store/index.js","../node_modules/svelte-spa-router/Router.svelte","../node_modules/regexparam/dist/index.mjs","../src/views/header/Index.svelte","../src/views/footer/Index.svelte","../src/lib/supabase.ts","../src/lib/util.ts","../src/component/diago.svelte","../src/views/index/Index.svelte","../src/views/about/Index.svelte","../src/views/error404/Index.svelte","../src/views/detail/Index.svelte","../src/views/subscribe/Index.svelte","../src/route/index.ts","../src/common/js/RibbonsEffect.js","../src/main.ts"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro  restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro  we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro  needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","/** @returns {{}} */\nexport function get_spread_update(levels, updates) {\n\tconst update = {};\n\tconst to_null_out = {};\n\tconst accounted_for = { $$scope: 1 };\n\tlet i = levels.length;\n\twhile (i--) {\n\t\tconst o = levels[i];\n\t\tconst n = updates[i];\n\t\tif (n) {\n\t\t\tfor (const key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\t\t\tfor (const key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (const key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\treturn update;\n}\n\nexport function get_spread_object(spread_props) {\n\treturn typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.$$l[type]) {\n\t\t\t\tconst idx = this.$$l[type].indexOf(listener);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tthis.$$l[type].splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn && this.$$c) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.20';\nexport const PUBLIC_VERSION = '4';\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","<script context=\"module\">\nimport {readable, writable, derived} from 'svelte/store'\nimport {tick} from 'svelte'\n\n/**\n * @typedef {Object} Location\n * @property {string} location - Location (page/view), for example `/book`\n * @property {string} [querystring] - Querystring from the hash, as a string not parsed\n */\n/**\n * Returns the current location from the hash.\n *\n * @returns {Location} Location object\n * @private\n */\nfunction getLocation() {\n    const hashPosition = window.location.href.indexOf('#/')\n    let location = (hashPosition > -1) ? window.location.href.substr(hashPosition + 1) : '/'\n\n    // Check if there's a querystring\n    const qsPosition = location.indexOf('?')\n    let querystring = ''\n    if (qsPosition > -1) {\n        querystring = location.substr(qsPosition + 1)\n        location = location.substr(0, qsPosition)\n    }\n\n    return {location, querystring}\n}\n\n/**\n * Readable store that returns the current full location (incl. querystring)\n */\nexport const loc = readable(\n    null,\n    // eslint-disable-next-line prefer-arrow-callback\n    function start(set) {\n        set(getLocation())\n\n        const update = () => {\n            set(getLocation())\n        }\n        window.addEventListener('hashchange', update, false)\n\n        return function stop() {\n            window.removeEventListener('hashchange', update, false)\n        }\n    }\n)\n\n/**\n * Readable store that returns the current location\n */\nexport const location = derived(\n    loc,\n    (_loc) => _loc.location\n)\n\n/**\n * Readable store that returns the current querystring\n */\nexport const querystring = derived(\n    loc,\n    (_loc) => _loc.querystring\n)\n\n/**\n * Store that returns the currently-matched params.\n * Despite this being writable, consumers should not change the value of the store.\n * It is exported as a readable store only (in the typings file)\n */\nexport const params = writable(undefined)\n\n/**\n * Navigates to a new page programmatically.\n *\n * @param {string} location - Path to navigate to (must start with `/` or '#/')\n * @return {Promise<void>} Promise that resolves after the page navigation has completed\n */\nexport async function push(location) {\n    if (!location || location.length < 1 || (location.charAt(0) != '/' && location.indexOf('#/') !== 0)) {\n        throw Error('Invalid parameter location')\n    }\n\n    // Execute this code when the current call stack is complete\n    await tick()\n\n    // Note: this will include scroll state in history even when restoreScrollState is false\n    history.replaceState({...history.state, __svelte_spa_router_scrollX: window.scrollX, __svelte_spa_router_scrollY: window.scrollY}, undefined)      \n    window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location\n}\n\n/**\n * Navigates back in history (equivalent to pressing the browser's back button).\n * \n * @return {Promise<void>} Promise that resolves after the page navigation has completed\n */\nexport async function pop() {\n    // Execute this code when the current call stack is complete\n    await tick()\n\n    window.history.back()\n}\n\n/**\n * Replaces the current page but without modifying the history stack.\n *\n * @param {string} location - Path to navigate to (must start with `/` or '#/')\n * @return {Promise<void>} Promise that resolves after the page navigation has completed\n */\nexport async function replace(location) {\n    if (!location || location.length < 1 || (location.charAt(0) != '/' && location.indexOf('#/') !== 0)) {\n        throw Error('Invalid parameter location')\n    }\n\n    // Execute this code when the current call stack is complete\n    await tick()\n\n    const dest = (location.charAt(0) == '#' ? '' : '#') + location\n    try {\n        const newState = {\n            ...history.state\n        }\n        delete newState['__svelte_spa_router_scrollX']\n        delete newState['__svelte_spa_router_scrollY']\n        window.history.replaceState(newState, undefined, dest)\n    }\n    catch (e) {\n        // eslint-disable-next-line no-console\n        console.warn('Caught exception while replacing the current page. If you\\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.')\n    }\n\n    // The method above doesn't trigger the hashchange event, so let's do that manually\n    window.dispatchEvent(new Event('hashchange'))\n}\n\n/**\n * Dictionary with options for the link action.\n * @typedef {Object} LinkActionOpts\n * @property {string} href - A string to use in place of the link's href attribute. Using this allows for updating link's targets reactively.\n * @property {boolean} disabled - If true, link is disabled\n */\n\n/**\n * Svelte Action that enables a link element (`<a>`) to use our history management.\n *\n * For example:\n *\n * ````html\n * <a href=\"/books\" use:link>View books</a>\n * ````\n *\n * @param {HTMLElement} node - The target node (automatically set by Svelte). Must be an anchor tag (`<a>`) with a href attribute starting in `/`\n * @param {string|LinkActionOpts} opts - Options object. For legacy reasons, we support a string too which will be the value for opts.href\n */\nexport function link(node, opts) {\n    opts = linkOpts(opts)\n\n    // Only apply to <a> tags\n    if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {\n        throw Error('Action \"link\" can only be used with <a> tags')\n    }\n\n    updateLink(node, opts)\n\n    return {\n        update(updated) {\n            updated = linkOpts(updated)\n            updateLink(node, updated)\n        }\n    }\n}\n\n/**\n * Tries to restore the scroll state from the given history state.\n *\n * @param {{__svelte_spa_router_scrollX: number, __svelte_spa_router_scrollY: number}} [state] - The history state to restore from.\n */\nexport function restoreScroll(state) {\n    // If this exists, then this is a back navigation: restore the scroll position\n    if (state) {\n        window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY)\n    }\n    else {\n        // Otherwise this is a forward navigation: scroll to top\n        window.scrollTo(0, 0)\n    }\n}\n\n// Internal function used by the link function\nfunction updateLink(node, opts) {\n    let href = opts.href || node.getAttribute('href')\n\n    // Destination must start with '/' or '#/'\n    if (href && href.charAt(0) == '/') {\n        // Add # to the href attribute\n        href = '#' + href\n    }\n    else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {\n        throw Error('Invalid value for \"href\" attribute: ' + href)\n    }\n\n    node.setAttribute('href', href)\n    node.addEventListener('click', (event) => {\n        // Prevent default anchor onclick behaviour\n        event.preventDefault()\n        if (!opts.disabled) {\n            scrollstateHistoryHandler(event.currentTarget.getAttribute('href'))\n        }\n    })\n}\n\n// Internal function that ensures the argument of the link action is always an object\nfunction linkOpts(val) {\n    if (val && typeof val == 'string') {\n        return {\n            href: val\n        }\n    }\n    else {\n        return val || {}\n    }\n}\n\n/**\n * The handler attached to an anchor tag responsible for updating the\n * current history state with the current scroll state\n *\n * @param {string} href - Destination\n */\nfunction scrollstateHistoryHandler(href) {\n    // Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that\n    history.replaceState({...history.state, __svelte_spa_router_scrollX: window.scrollX, __svelte_spa_router_scrollY: window.scrollY}, undefined)\n    // This will force an update as desired, but this time our scroll state will be attached\n    window.location.hash = href\n}\n</script>\n\n{#if componentParams}\n    <svelte:component\n    this={component}\n    params={componentParams}\n    on:routeEvent\n    {...props}\n    />\n{:else}\n    <svelte:component\n    this={component}\n    on:routeEvent\n    {...props}\n    />\n{/if}\n\n<script>\nimport {onDestroy, createEventDispatcher, afterUpdate} from 'svelte'\nimport {parse} from 'regexparam'\n\n/**\n * Dictionary of all routes, in the format `'/path': component`.\n *\n * For example:\n * ````js\n * import HomeRoute from './routes/HomeRoute.svelte'\n * import BooksRoute from './routes/BooksRoute.svelte'\n * import NotFoundRoute from './routes/NotFoundRoute.svelte'\n * routes = {\n *     '/': HomeRoute,\n *     '/books': BooksRoute,\n *     '*': NotFoundRoute\n * }\n * ````\n */\nexport let routes = {}\n\n/**\n * Optional prefix for the routes in this router. This is useful for example in the case of nested routers.\n */\nexport let prefix = ''\n\n/**\n * If set to true, the router will restore scroll positions on back navigation\n * and scroll to top on forward navigation.\n */\nexport let restoreScrollState = false\n\n/**\n * Container for a route: path, component\n */\nclass RouteItem {\n    /**\n     * Initializes the object and creates a regular expression from the path, using regexparam.\n     *\n     * @param {string} path - Path to the route (must start with '/' or '*')\n     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped\n     */\n    constructor(path, component) {\n        if (!component || (typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true))) {\n            throw Error('Invalid component object')\n        }\n\n        // Path must be a regular or expression, or a string starting with '/' or '*'\n        if (!path || \n            (typeof path == 'string' && (path.length < 1 || (path.charAt(0) != '/' && path.charAt(0) != '*'))) ||\n            (typeof path == 'object' && !(path instanceof RegExp))\n        ) {\n            throw Error('Invalid value for \"path\" argument - strings must start with / or *')\n        }\n\n        const {pattern, keys} = parse(path)\n\n        this.path = path\n\n        // Check if the component is wrapped and we have conditions\n        if (typeof component == 'object' && component._sveltesparouter === true) {\n            this.component = component.component\n            this.conditions = component.conditions || []\n            this.userData = component.userData\n            this.props = component.props || {}\n        }\n        else {\n            // Convert the component to a function that returns a Promise, to normalize it\n            this.component = () => Promise.resolve(component)\n            this.conditions = []\n            this.props = {}\n        }\n\n        this._pattern = pattern\n        this._keys = keys\n    }\n\n    /**\n     * Checks if `path` matches the current route.\n     * If there's a match, will return the list of parameters from the URL (if any).\n     * In case of no match, the method will return `null`.\n     *\n     * @param {string} path - Path to test\n     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.\n     */\n    match(path) {\n        // If there's a prefix, check if it matches the start of the path.\n        // If not, bail early, else remove it before we run the matching.\n        if (prefix) {\n            if (typeof prefix == 'string') {\n                if (path.startsWith(prefix)) {\n                    path = path.substr(prefix.length) || '/'\n                }\n                else {\n                    return null\n                }\n            }\n            else if (prefix instanceof RegExp) {\n                const match = path.match(prefix)\n                if (match && match[0]) {\n                    path = path.substr(match[0].length) || '/'\n                }\n                else {\n                    return null\n                }\n            }\n        }\n\n        // Check if the pattern matches\n        const matches = this._pattern.exec(path)\n        if (matches === null) {\n            return null\n        }\n\n        // If the input was a regular expression, this._keys would be false, so return matches as is\n        if (this._keys === false) {\n            return matches\n        }\n\n        const out = {}\n        let i = 0\n        while (i < this._keys.length) {\n            // In the match parameters, URL-decode all values\n            try {\n                out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null\n            }\n            catch (e) {\n                out[this._keys[i]] = null\n            }\n            i++\n        }\n        return out\n    }\n\n    /**\n     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events\n     * @typedef {Object} RouteDetail\n     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)\n     * @property {string} location - Location path\n     * @property {string} querystring - Querystring from the hash\n     * @property {object} [userData] - Custom data passed by the user\n     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)\n     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)\n     */\n\n    /**\n     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.\n     * \n     * @param {RouteDetail} detail - Route detail\n     * @returns {boolean} Returns true if all the conditions succeeded\n     */\n    async checkConditions(detail) {\n        for (let i = 0; i < this.conditions.length; i++) {\n            if (!(await this.conditions[i](detail))) {\n                return false\n            }\n        }\n\n        return true\n    }\n}\n\n// Set up all routes\nconst routesList = []\nif (routes instanceof Map) {\n    // If it's a map, iterate on it right away\n    routes.forEach((route, path) => {\n        routesList.push(new RouteItem(path, route))\n    })\n}\nelse {\n    // We have an object, so iterate on its own properties\n    Object.keys(routes).forEach((path) => {\n        routesList.push(new RouteItem(path, routes[path]))\n    })\n}\n\n// Props for the component to render\nlet component = null\nlet componentParams = null\nlet props = {}\n\n// Event dispatcher from Svelte\nconst dispatch = createEventDispatcher()\n\n// Just like dispatch, but executes on the next iteration of the event loop\nasync function dispatchNextTick(name, detail) {\n    // Execute this code when the current call stack is complete\n    await tick()\n    dispatch(name, detail)\n}\n\n// If this is set, then that means we have popped into this var the state of our last scroll position\nlet previousScrollState = null\n\n// Update history.scrollRestoration depending on restoreScrollState\n$: history.scrollRestoration = restoreScrollState ? 'manual' : 'auto'\nlet popStateChanged = null\nif (restoreScrollState) {\n    popStateChanged = (event) => {\n        // If this event was from our history.replaceState, event.state will contain\n        // our scroll history. Otherwise, event.state will be null (like on forward\n        // navigation)\n        if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {\n            previousScrollState = event.state\n        }\n        else {\n            previousScrollState = null\n        }\n    }\n    // This is removed in the destroy() invocation below\n    window.addEventListener('popstate', popStateChanged)\n\n    afterUpdate(() => {\n        restoreScroll(previousScrollState)\n    })\n}\n\n// Always have the latest value of loc\nlet lastLoc = null\n\n// Current object of the component loaded\nlet componentObj = null\n\n// Handle hash change events\n// Listen to changes in the $loc store and update the page\n// Do not use the $: syntax because it gets triggered by too many things\nconst unsubscribeLoc = loc.subscribe(async (newLoc) => {\n    lastLoc = newLoc\n\n    // Find a route matching the location\n    let i = 0\n    while (i < routesList.length) {\n        const match = routesList[i].match(newLoc.location)\n        if (!match) {\n            i++\n            continue\n        }\n\n        const detail = {\n            route: routesList[i].path,\n            location: newLoc.location,\n            querystring: newLoc.querystring,\n            userData: routesList[i].userData,\n            params: (match && typeof match == 'object' && Object.keys(match).length) ? match : null\n        }\n\n        // Check if the route can be loaded - if all conditions succeed\n        if (!(await routesList[i].checkConditions(detail))) {\n            // Don't display anything\n            component = null\n            componentObj = null\n            // Trigger an event to notify the user, then exit\n            dispatchNextTick('conditionsFailed', detail)\n            return\n        }\n\n        // Trigger an event to alert that we're loading the route\n        // We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick\n        dispatchNextTick('routeLoading', Object.assign({}, detail))\n\n        // If there's a component to show while we're loading the route, display it\n        const obj = routesList[i].component\n        // Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted\n        if (componentObj != obj) {\n            if (obj.loading) {\n                component = obj.loading\n                componentObj = obj\n                componentParams = obj.loadingParams\n                props = {}\n\n                // Trigger the routeLoaded event for the loading component\n                // Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)\n                dispatchNextTick('routeLoaded', Object.assign({}, detail, {\n                    component: component,\n                    name: component.name,\n                    params: componentParams\n                }))\n            }\n            else {\n                component = null\n                componentObj = null\n            }\n\n            // Invoke the Promise\n            const loaded = await obj()\n\n            // Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile\n            if (newLoc != lastLoc) {\n                // Don't update the component, just exit\n                return\n            }\n\n            // If there is a \"default\" property, which is used by async routes, then pick that\n            component = (loaded && loaded.default) || loaded\n            componentObj = obj\n        }\n\n        // Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`\n        // Of course, this assumes that developers always add a \"params\" prop when they are expecting parameters\n        if (match && typeof match == 'object' && Object.keys(match).length) {\n            componentParams = match\n        }\n        else {\n            componentParams = null\n        }\n\n        // Set static props, if any\n        props = routesList[i].props\n\n        // Dispatch the routeLoaded event then exit\n        // We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick\n        dispatchNextTick('routeLoaded', Object.assign({}, detail, {\n            component: component,\n            name: component.name,\n            params: componentParams\n        })).then(() => {\n            params.set(componentParams)\n        })\n        return\n    }\n\n    // If we're still here, there was no match, so show the empty component\n    component = null\n    componentObj = null\n    params.set(undefined)\n})\n\nonDestroy(() => {\n    unsubscribeLoc()\n    popStateChanged && window.removeEventListener('popstate', popStateChanged)\n})\n</script>\n","export function parse(str, loose) {\n\tif (str instanceof RegExp) return { keys:false, pattern:str };\n\tvar c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');\n\tarr[0] || arr.shift();\n\n\twhile (tmp = arr.shift()) {\n\t\tc = tmp[0];\n\t\tif (c === '*') {\n\t\t\tkeys.push('wild');\n\t\t\tpattern += '/(.*)';\n\t\t} else if (c === ':') {\n\t\t\to = tmp.indexOf('?', 1);\n\t\t\text = tmp.indexOf('.', 1);\n\t\t\tkeys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );\n\t\t\tpattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';\n\t\t\tif (!!~ext) pattern += (!!~o ? '?' : '') + '\\\\' + tmp.substring(ext);\n\t\t} else {\n\t\t\tpattern += '/' + tmp;\n\t\t}\n\t}\n\n\treturn {\n\t\tkeys: keys,\n\t\tpattern: new RegExp('^' + pattern + (loose ? '(?=$|\\/)' : '\\/?$'), 'i')\n\t};\n}\n\nvar RGX = /(\\/|^)([:*][^/]*?)(\\?)?(?=[/.]|$)/g;\n\n// error if key missing?\nexport function inject(route, values) {\n\treturn route.replace(RGX, (x, lead, key, optional) => {\n\t\tx = values[key=='*' ? 'wild' : key.substring(1)];\n\t\treturn x ? '/'+x : (optional || key=='*') ? '' : '/' + key;\n\t});\n}\n","<script lang=\"ts\">\n    import { link } from \"svelte-spa-router\"; //  action\n</script>\n\n<!-- HTML  +  +  -->\n<header class=\"header\">\n    <div class=\"container\">\n        <a href=\"/\" class=\"logo\"> - Why128</a>\n        <nav class=\"nav\">\n            <ul>\n                <li><a href=\"/\"></a></li>\n                <li><a href=\"/about\" use:link></a></li>\n                <li><a href=\"/subscribe\" use:link></a></li>\n            </ul>\n        </nav>\n    </div>\n</header>\n\n<style>\n    /*  */\n    .header {\n        background: rgba(255, 255, 255, 0.3);\n        border-bottom: 1px solid #eee;\n        position: sticky;\n        top: 0;\n        z-index: 10;\n        padding: 15px 0;\n    }\n    .header .container {\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n    }\n    .logo {\n        font-size: 24px;\n        font-weight: bold;\n        color: #333;\n        text-decoration: none;\n    }\n    .nav ul {\n        list-style: none;\n        display: flex;\n        gap: 30px;\n        margin: 0;\n        padding: 0;\n    }\n    .nav a {\n        text-decoration: none;\n        color: #333;\n        font-size: 16px;\n        transition: color 0.3s ease;\n    }\n    .nav a:hover {\n        color: #007acc;\n    }\n    @media (max-width: 768px) {\n        .header .container {\n            flex-direction: column;\n            gap: 10px;\n        }\n        .nav ul {\n            gap: 20px;\n            flex-wrap: wrap;\n            justify-content: center;\n        }\n    }\n</style>\n","<script lang=\"ts\">\n    import { link } from \"svelte-spa-router\";\n</script>\n\n<footer class=\"footer\">\n    <div class=\"container\">\n        <p>\n            &copy; 2025 MintYouth. Powered by Typecho. <a\n                href=\"/subscribe\"\n                use:link>RSS</a\n            >\n            |\n            <a target=\"_blank\" href=\"https://github.com/why128\">GitHub</a>\n        </p>\n    </div>\n</footer>\n\n<style>\n    /*  */\n    .footer {\n        background: rgba(248, 249, 250, 0.3);\n        border-top: 1px solid #eee;\n        padding: 20px 0;\n        text-align: center;\n        font-size: 14px;\n        color: #999;\n    }\n    .footer a {\n        color: #007acc;\n        text-decoration: none;\n    }\n    .footer a:hover {\n        text-decoration: underline;\n    }\n</style>\n","const WORKER_URL = 'https://githubio.wattley.top/';\nconst FRONTEND_TOKEN = '123456789';\n// DUMMY_KEY  Supabase  public anon key\nconst DUMMY_KEY = 'DUMMY_KEY';\n\n/**\n *  Supabase PostgREST Client Worker \n */\nclass SupabaseWorkerClient {\n    url: string;\n    token: string;\n\n    constructor(url: string, token: string) {\n        this.url = url;\n        this.token = token;\n    }\n\n    from(table: string) {\n        const self = this;\n        // Query \n        const query = {\n            table,\n            selectCols: '*',\n            orders: [] as { column: string, ascending: boolean }[],\n            limit: null as number | null,\n            offset: null as number | null,\n            filters: [] as any[],\n            body: null as any,\n        };\n\n        /**\n         *  URL\n         */\n        const buildUrl = () => {\n            const params = new URLSearchParams();\n            params.set('select', query.selectCols);\n\n            if (query.orders.length > 0) {\n                const orderStr = query.orders.map(o => `${o.column}.${o.ascending ? 'asc' : 'desc'}`).join(',');\n                params.set('order', orderStr);\n            }\n\n            if (query.limit !== null) params.set('limit', query.limit.toString());\n            if (query.offset !== null) params.set('offset', query.offset.toString());\n\n            if (query.filters.length > 0) {\n                query.filters.forEach((f: { column: string, operator: string, value: any }) => {\n                    const op = f.operator || 'eq';\n                    const value = Array.isArray(f.value) && op === 'in' ? `{${f.value.join(',')}}` : f.value;\n                    params.append(f.column, `${op}.${value}`);\n                });\n            }\n\n            const baseUrl = self.url.endsWith('/') ? self.url.slice(0, -1) : self.url;\n            return `${baseUrl}/rest/v1/${query.table}?${params.toString()}`;\n        };\n\n        /**\n         *  Fetch \n         * \n         */\n        const fetchRequest = async (method: string, prefer?: string): Promise<{ data: any | null, error: { message: string, status: number } | null, count?: number | null }> => {\n            const url = buildUrl();\n            const headers: Record<string, string> = {\n                'X-API-Token': self.token,\n                'Authorization': `Bearer ${DUMMY_KEY}`,\n                'apikey': DUMMY_KEY,\n                'Content-Type': 'application/json',\n                'accept-profile': 'public',\n            };\n\n            if (prefer) {\n                headers['Prefer'] = prefer;\n            }\n\n            const res = await fetch(url, {\n                method,\n                headers,\n                body: ['GET', 'HEAD'].includes(method) ? undefined : JSON.stringify(query.body),\n            });\n\n            try {\n                if (!res.ok) {\n                    const errorText = await res.text();\n                    let errorJson = null;\n                    try {\n                        errorJson = JSON.parse(errorText);\n                    } catch { /* ignored */ }\n                    const message = errorJson?.message || errorJson?.error || errorText;\n                    return { data: null, error: { message: `[${res.status} ${res.statusText}] ${message}`, status: res.status } };\n                }\n\n                //  204 No Content \n                if (res.status === 204) {\n                    return { data: [], error: null, count: null };\n                }\n\n                //  res.json()\n                const responseText = await res.text();\n\n                if (responseText.length === 0) {\n                    //  OK ( 200, 201) \n                    return { data: [], error: null, count: null };\n                }\n\n                //  JSON\n                const data = JSON.parse(responseText);\n                // \n\n                const count = prefer?.includes('count=exact')\n                    ? parseInt(res.headers.get('content-range')?.split('/')[1] || '0')\n                    : null;\n\n                return { data, error: null, count };\n\n            } catch (e: any) {\n                //  JSON \n                return { data: null, error: { message: `Client Error: Failed to process response. ${e.message || e}`, status: res.status } };\n            }\n        };\n\n        // \n        const chain: any = {\n            // ... (select, get ) ...\n            select(columns: string = '*') {\n                query.selectCols = columns;\n                return this;\n            },\n\n            get({ count = null }: { count?: 'exact' | null } = {}) {\n                let prefer = '';\n                if (count === 'exact') {\n                    prefer = 'count=exact';\n                }\n                return fetchRequest('GET', prefer);\n            },\n\n            // =========================================================================\n            // CRUD - MUTATIONS ()\n            // =========================================================================\n\n            insert(data: any, { returning = 'representation' }: { returning?: 'minimal' | 'representation' } = {}) {\n                query.body = Array.isArray(data) ? data : [data];\n                const prefer = `return=${returning}`;\n                return fetchRequest('POST', prefer);\n            },\n\n            /**\n             *  (UPDATE)  PATCH \n             */\n            update(data: any, { returning = 'representation' }: { returning?: 'minimal' | 'representation' } = {}) {\n                query.body = data;\n                const prefer = `return=${returning}`;\n                //   PATCH\n                return fetchRequest('PATCH', prefer);\n            },\n\n            delete({ returning = 'minimal' }: { returning?: 'minimal' | 'representation' } = {}) {\n                const prefer = `return=${returning}`;\n                return fetchRequest('DELETE', prefer);\n            },\n\n            // ... (QUERY MODIFIERS & FILTERS ) ...\n            order(column: string, { ascending = true } = {}) { query.orders.push({ column, ascending }); return this; },\n            limit(count: number) { query.limit = count; return this; },\n            range(from: number, to: number) { query.offset = from; query.limit = to - from + 1; return this; },\n            eq(column: string, value: any) { query.filters.push({ column, value, operator: 'eq' }); return this; },\n            neq(column: string, value: any) { query.filters.push({ column, value, operator: 'neq' }); return this; },\n            gt(column: string, value: any) { query.filters.push({ column, value, operator: 'gt' }); return this; },\n            gte(column: string, value: any) { query.filters.push({ column, value, operator: 'gte' }); return this; },\n            lt(column: string, value: any) { query.filters.push({ column, value, operator: 'lt' }); return this; },\n            lte(column: string, value: any) { query.filters.push({ column, value, operator: 'lte' }); return this; },\n            like(column: string, pattern: string) { query.filters.push({ column, value: pattern, operator: 'like' }); return this; },\n            ilike(column: string, pattern: string) { query.filters.push({ column, value: pattern, operator: 'ilike' }); return this; },\n            in(column: string, values: any[]) { query.filters.push({ column, value: values, operator: 'in' }); return this; },\n            match(obj: Record<string, any>) {\n                Object.entries(obj).forEach(([col, val]) => query.filters.push({ column: col, value: val, operator: 'eq' }));\n                return this;\n            },\n        };\n\n        return chain;\n    }\n}\n\n// \nconst supabase = new SupabaseWorkerClient(WORKER_URL, FRONTEND_TOKEN);\n\nexport default supabase;","\n\n// \nconst pad2 = (n: number) => String(n).padStart(2, \"0\");\n\nconst formatDate2 = (d = new Date()) =>\n    `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;\nexport function formatTime(time: string) {\n    const date = new Date(time);\n    return `${formatDate2(new Date(date.toLocaleDateString()))} ${date.toLocaleTimeString()}`;\n};\n","<script lang=\"ts\">\n    import loading from \"$common/image/loading.gif\";\n\n    export let diago = true;\n</script>\n\n{#if diago}\n    <div class=\"diago\">\n        <img src={loading} alt=\"\" />\n        <p>...</p>\n    </div>\n{/if}\n\n<style>\n    .diago {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        z-index: 99;\n        background: rgba(0, 0, 0, 0.8);\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        flex-direction: column;\n    }\n    .diago img {\n        display: block;\n        border-radius: 50%;\n        width: 200px;\n        height: 200px;\n        opacity: 0.5;\n    }\n    .diago p {\n        font-size: 20px;\n        color: #eee;\n        letter-spacing: 0.2em;\n    }\n</style>\n","<script lang=\"ts\">\n    import Header from \"@/views/header/Index.svelte\";\n    import Footer from \"@/views/footer/Index.svelte\";\n    import supabase from \"$lib/supabase\";\n    import { onMount } from \"svelte\";\n    import { link } from \"svelte-spa-router\";\n    import { formatTime } from \"$lib/util\";\n    import Diago from \"@/component/diago.svelte\";\n    // TS \n    interface Post {\n        id: number;\n        title: string;\n        date: string;\n        excerpt: string;\n        content: string;\n        link: string; // \n        readTime?: number; // \n    }\n    // \n    let loading = false;\n    // \n    let posts: Post[] = [];\n    // \n    let currentPage = 1;\n    let size = 2;\n    let totalPages = 1;\n    async function getData(page: number, size: number) {\n        loading = true;\n        const { data, error } = await supabase\n            .from(\"githubio_list\")\n            .order(\"id\", { ascending: false })\n            .range((page - 1) * size, page * size - 1) // offset + limit \n            .select(\"id,title,date,excerpt,content,link,readTime\")\n            .get(); // \n        if (error) {\n            console.error(\" (Error)\", error);\n\n            //  status \n            if (error.status === 401) {\n                console.warn(\n                    \": 401 Unauthorized -  FRONTEND_TOKEN  DUMMY_KEY\",\n                );\n            } else if (error.status === 404) {\n                console.warn(\n                    `: 404 Not Found -  githubio_list `,\n                );\n            } else {\n                console.warn(`:  Status ${error.status}`);\n            }\n            return null;\n        }\n        posts = data.map((v: Post) => ({\n            id: v.id,\n            title: v.title,\n            date: formatTime(v.date),\n            excerpt: v.excerpt,\n            content: v.content,\n            link: v.link,\n            readTime: v.readTime,\n        }));\n        loading = false;\n    }\n\n    (async () => {\n        const { data: totalData, error: totalError } = await supabase\n            .from(\"githubio_list\")\n            .select(\"id\")\n            .get({ count: \"exact\" });\n        if (totalError) {\n            console.error(\" (Error)\", totalError);\n            return null;\n        }\n        totalPages = Math.ceil(totalData.length / size);\n    })();\n\n    // \n    function goToPage(page: number) {\n        currentPage = page;\n        //  posts...\n        getData(currentPage, size);\n    }\n\n    onMount(() => {\n        getData(currentPage, size);\n    });\n</script>\n\n<Diago diago={loading} />\n<Header />\n<main class=\"main\">\n    <div class=\"container\">\n        <div class=\"posts\">\n            {#each posts as post}\n                <article class=\"post-item\">\n                    <h2 class=\"post-title\">\n                        <a href={`${post.link}/${post.id}`} use:link\n                            >{post.title}</a\n                        >\n                    </h2>\n                    <div class=\"post-meta\">\n                        <span class=\"date\">{post.date}</span>\n                        <span class=\"read-time\"> {post.readTime} </span>\n                    </div>\n                    <p class=\"post-excerpt\">{post.excerpt}</p>\n                    <a\n                        href={`${post.link}/${post.id}`}\n                        use:link\n                        class=\"read-more\"> </a\n                    >\n                </article>\n            {/each}\n        </div>\n\n        <!--  -->\n        {#if totalPages > 1}\n            <nav class=\"pagination\">\n                <ul>\n                    {#if currentPage > 1}\n                        <li>\n                            <a\n                                href=\"#\"\n                                on:click|preventDefault={() =>\n                                    goToPage(currentPage - 1)}></a\n                            >\n                        </li>\n                    {/if}\n                    {#each Array.from({ length: totalPages }, (_, i) => i + 1) as page}\n                        <li class:active={page === currentPage}>\n                            <a\n                                href=\"#\"\n                                on:click|preventDefault={() => goToPage(page)}\n                                >{page}</a\n                            >\n                        </li>\n                    {/each}\n                    {#if currentPage < totalPages}\n                        <li>\n                            <a\n                                href=\"#\"\n                                on:click|preventDefault={() =>\n                                    goToPage(currentPage + 1)}></a\n                            >\n                        </li>\n                    {/if}\n                </ul>\n            </nav>\n        {/if}\n    </div>\n</main>\n<Footer />\n\n<style>\n    .posts {\n        display: flex;\n        flex-direction: column;\n        gap: 30px;\n    }\n    .post-item {\n        background: rgba(255, 255, 255, 0.6);\n        border: 1px solid #eee;\n        border-radius: 8px;\n        padding: 25px;\n        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);\n        transition: box-shadow 0.3s ease;\n    }\n    .post-item:hover {\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n    }\n    .post-title {\n        margin: 0 0 10px 0;\n        font-size: 20px;\n    }\n    .post-title a {\n        color: #222;\n        text-decoration: none;\n    }\n    .post-title a:hover {\n        color: #007acc;\n    }\n    .post-meta {\n        font-size: 14px;\n        color: #999;\n        margin-bottom: 15px;\n    }\n    .post-excerpt {\n        margin: 0 0 15px 0;\n        color: #666;\n    }\n    .read-more {\n        font-size: 14px;\n        color: #007acc;\n        text-decoration: none;\n    }\n    .read-more:hover {\n        text-decoration: underline;\n    }\n\n    /*  */\n    .pagination {\n        margin-top: 40px;\n        text-align: center;\n    }\n    .pagination ul {\n        list-style: none;\n        display: flex;\n        justify-content: center;\n        gap: 10px;\n        margin: 0;\n        padding: 0;\n    }\n    .pagination li {\n        display: inline-block;\n    }\n    .pagination a {\n        display: block;\n        padding: 8px 12px;\n        border: 1px solid #ddd;\n        border-radius: 4px;\n        text-decoration: none;\n        color: #333;\n        transition: background 0.3s;\n    }\n    .pagination a:hover {\n        background: #f5f5f5;\n    }\n    .pagination .active a {\n        background: #007acc;\n        color: #fff;\n        border-color: #007acc;\n    }\n    @media (max-width: 768px) {\n        .pagination ul {\n            flex-wrap: wrap;\n            gap: 5px;\n        }\n    }\n</style>\n","<script>\n    import supabase from \"$lib/supabase\";\n    import Header from \"@/views/header/Index.svelte\";\n    import Footer from \"@/views/footer/Index.svelte\";\n    // \n    (async () => {\n        const data = await supabase\n            .from(\"githubio_list\")\n            .order(\"id\", { ascending: false })\n            .range(0, 9) // offset + limit \n            .select(\"*\"); // \n        console.log(data);\n    })();\n</script>\n\n<Header />\n<div class=\"main\">\n    <div class=\"container\">\n        <div class=\"item avatar\">\n            <p></p>\n            <img\n                src=\"https://image.wattley.top/file/AgACAgUAAyEGAATPGd8VAAPAaTAhW3MoHwz_siovOi_lVpDsWlYAAkoMaxvSYoBVywkOTEoeGvQBAAMCAAN4AAM2BA.jpg\"\n                alt=\"\"\n            />\n        </div>\n        <div class=\"item avatar\">\n            <p></p>\n            <p>https://why128.github.io</p>\n        </div>\n        <div class=\"item avatar\">\n            <p></p>\n            <p></p>\n        </div>\n        <div class=\"item avatar\">\n            <p></p>\n            <p>+1 571 530 2930 (USA)</p>\n        </div>\n        <div class=\"item tg\">\n            <p>TG</p>\n            <a target=\"_blank\" href=\"https://t.me/githubio_why128\"\n                >@githubio_why128</a\n            >\n        </div>\n    </div>\n</div>\n<Footer />\n\n<style>\n    .item {\n        height: 120px;\n        display: flex;\n        align-items: center;\n        justify-content: flex-start;\n    }\n    .item p {\n        font-size: 20px;\n        color: #333;\n        margin-right: 50px;\n    }\n    .tg a {\n        font-size: 20px;\n        color: #007bff;\n    }\n    .avatar img {\n        width: 100px;\n        height: 100px;\n        border-radius: 50%;\n    }\n</style>\n","<h1>error 404</h1>\n","<script lang=\"ts\">\n    import Header from \"@/views/header/Index.svelte\";\n    import Footer from \"@/views/footer/Index.svelte\";\n    import supabase from \"$lib/supabase\";\n    import { onMount } from \"svelte\";\n    import { formatTime } from \"$lib/util\";\n    import Diago from \"@/component/diago.svelte\";\n    // url id\n    let loading = true;\n    export let params: { [key: string]: string };\n    interface Post {\n        id: number;\n        title: string;\n        date: string;\n        excerpt: string;\n        content: string;\n        link: string; // \n        readTime?: number; // \n    }\n    let post: Post | null = null;\n    async function getData(id: number) {\n        const { data, error } = await supabase\n            .from(\"githubio_list\")\n            .select(\"id,title,date,excerpt,content,link,readTime\")\n            .eq(\"id\", id)\n            .get();\n        if (error) {\n            console.error(\" (Error)\", error);\n            return null;\n        }\n        post = data[0];\n        //\n        const currentReadTime = post?.readTime || 0; //  readtime  0\n        const newReadTime = currentReadTime + 1;\n        const { data: dataup, error: errorup } = await supabase\n            .from(\"githubio_list\")\n            .eq(\"id\", id)\n            .update({ readTime: newReadTime }, { returning: \"minimal\" });\n        if (errorup) {\n            console.error(\" readtime :\", errorup);\n        } else {\n            console.log(\"readtime \");\n        }\n        loading = false;\n    }\n    onMount(() => {\n        //\n        getData(Number(params.id));\n    });\n    function goback() {\n        window.location.hash = \"#/\";\n    }\n</script>\n\n<Diago diago={loading} />\n<Header />\n<div class=\"main\">\n    <div class=\"container\">\n        {#if post}\n            <h2>\n                {post?.title}\n                <button class=\"btn btn-primary\" type=\"button\" on:click={goback}\n                    ></button\n                >\n            </h2>\n            <div class=\"sub-title\">\n                <p class=\"date\">: {formatTime(post?.date)}</p>\n                <p class=\"readtime\">: {Number(post?.readTime) + 1}</p>\n            </div>\n            <div class=\"content-html\">{@html post?.content}</div>\n        {/if}\n    </div>\n</div>\n<Footer />\n\n<style>\n    /*  */\n    .btn {\n        padding: 0.5rem 1rem;\n        border-radius: 0.25rem;\n        border: 1px solid #ccc;\n        border-color: none;\n        background-color: #fff;\n        cursor: pointer;\n        display: block;\n        float: right;\n    }\n    .btn-primary {\n        background-color: #007bff;\n        color: #fff;\n    }\n    .sub-title {\n        display: flex;\n    }\n    .sub-title .date {\n        font-size: 14px;\n        color: #666;\n    }\n    .sub-title .readtime {\n        font-size: 14px;\n        color: #666;\n        margin-left: 50px;\n    }\n    .content-html {\n        font-size: 18px;\n        color: #971701;\n        word-wrap: break-word;\n        white-space: pre-wrap;\n    }\n    .content-html :global(*) {\n        white-space: pre-wrap;\n        word-wrap: break-word;\n    }\n</style>\n","<script>\n    import supabase from \"$lib/supabase\";\n    import Header from \"@/views/header/Index.svelte\";\n    import Footer from \"@/views/footer/Index.svelte\";\n</script>\n\n<Header />\n<div class=\"main\">\n    <div class=\"container\">\n        <div class=\"text\">TG</div>\n    </div>\n</div>\n<Footer />\n\n<style>\n    .text {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        font-size: 30px;\n        height: 300px;\n    }\n</style>\n","import Index from \"@/views/index/Index.svelte\";\nimport About from \"@/views/about/Index.svelte\";\nimport Error404 from \"@/views/error404/Index.svelte\";\nimport Detail from \"@/views/detail/Index.svelte\";\nimport Subscribe from \"@/views/subscribe/Index.svelte\";\n\nconst routes: object = {\n    \"/\": Index,\n    \"/about\": About,\n    \"/detail/:id\": Detail,\n    \"/subscribe\": Subscribe,\n    // '/user/:id': User\n    \"*\": Error404, // 404 \n};\n\nexport default routes","\"object\" == typeof window && (window.Ribbons = function () {\n    var h = window\n        , e = document.body\n        , a = document.documentElement\n        , u = function () {\n            if (1 === arguments.length) {\n                if (Array.isArray(arguments[0])) {\n                    var t = Math.round(u(0, arguments[0].length - 1));\n                    return arguments[0][t]\n                }\n                return u(0, arguments[0])\n            }\n            return 2 === arguments.length ? Math.random() * (arguments[1] - arguments[0]) + arguments[0] : 0\n        }\n        , n = function (t) {\n            var i = Math.max(0, h.innerWidth || a.clientWidth || e.clientWidth || 0)\n                , n = Math.max(0, h.innerHeight || a.clientHeight || e.clientHeight || 0)\n                , o = Math.max(0, h.pageXOffset || a.scrollLeft || e.scrollLeft || 0) - (a.clientLeft || 0)\n                , s = Math.max(0, h.pageYOffset || a.scrollTop || e.scrollTop || 0) - (a.clientTop || 0);\n            return {\n                width: i,\n                height: n,\n                ratio: i / n,\n                centerx: i / 2,\n                centery: n / 2,\n                scrollx: o,\n                scrolly: s\n            }\n        }\n        , b = function (t, i) {\n            this.x = 0,\n                this.y = 0,\n                this.set(t, i)\n        };\n    b.prototype = {\n        constructor: b,\n        set: function (t, i) {\n            this.x = t || 0,\n                this.y = i || 0\n        },\n        copy: function (t) {\n            return this.x = t.x || 0,\n                this.y = t.y || 0,\n                this\n        },\n        multiply: function (t, i) {\n            return this.x *= t || 1,\n                this.y *= i || 1,\n                this\n        },\n        divide: function (t, i) {\n            return this.x /= t || 1,\n                this.y /= i || 1,\n                this\n        },\n        add: function (t, i) {\n            return this.x += t || 0,\n                this.y += i || 0,\n                this\n        },\n        subtract: function (t, i) {\n            return this.x -= t || 0,\n                this.y -= i || 0,\n                this\n        },\n        clampX: function (t, i) {\n            return this.x = Math.max(t, Math.min(this.x, i)),\n                this\n        },\n        clampY: function (t, i) {\n            return this.y = Math.max(t, Math.min(this.y, i)),\n                this\n        },\n        flipX: function () {\n            return this.x *= -1,\n                this\n        },\n        flipY: function () {\n            return this.y *= -1,\n                this\n        }\n    };\n    var t = function (t) {\n        this._canvas = null,\n            this._context = null,\n            this._sto = null,\n            this._width = 0,\n            this._height = 0,\n            this._scroll = 0,\n            this._ribbons = [],\n            this._options = {\n                colorSaturation: \"80%\",\n                colorBrightness: \"60%\",\n                colorAlpha: .65,\n                colorCycleSpeed: 6,\n                verticalPosition: \"center\",\n                horizontalSpeed: 150,\n                ribbonCount: 3,\n                strokeSize: 0,\n                parallaxAmount: -.5,\n                animateSections: !0\n            },\n            this._onDraw = this._onDraw.bind(this),\n            this._onResize = this._onResize.bind(this),\n            this._onScroll = this._onScroll.bind(this),\n            this.setOptions(t),\n            this.init()\n    };\n    return t.prototype = {\n        constructor: t,\n        setOptions: function (t) {\n            if (\"object\" == typeof t)\n                for (var i in t)\n                    t.hasOwnProperty(i) && (this._options[i] = t[i])\n        },\n        init: function () {\n            try {\n                this._canvas = document.createElement(\"canvas\"),\n                    this._canvas.style.display = \"block\",\n                    this._canvas.style.position = \"fixed\",\n                    this._canvas.style.margin = \"0\",\n                    this._canvas.style.padding = \"0\",\n                    this._canvas.style.border = \"0\",\n                    this._canvas.style.outline = \"0\",\n                    this._canvas.style.left = \"0\",\n                    this._canvas.style.top = \"0\",\n                    this._canvas.style.right = \"0\",\n                    this._canvas.style.bottom = \"0\",\n                    this._canvas.style.width = \"100%\",\n                    this._canvas.style.height = \"100%\",\n                    this._canvas.style[\"z-index\"] = \"-1\",\n                    this._canvas.id = \"bgCanvas\",\n                    this._onResize(),\n                    this._context = this._canvas.getContext(\"2d\"),\n                    this._context.clearRect(0, 0, this._width, this._height),\n                    this._context.globalAlpha = this._options.colorAlpha,\n                    window.addEventListener(\"resize\", this._onResize),\n                    window.addEventListener(\"scroll\", this._onScroll),\n                    document.body.appendChild(this._canvas)\n            } catch (t) {\n                return void console.warn(\"Canvas Context Error: \" + t.toString())\n            }\n            this._onDraw()\n        },\n        addRibbon: function () {\n            var t = 5 < Math.round(u(1, 9)) ? \"right\" : \"left\"\n                , i = 1e3\n                , n = 200\n                , o = this._width + n\n                , s = 0\n                , h = 0\n                , e = \"right\" === t ? -200 : o\n                , a = Math.round(u(0, this._height));\n            /^(top|min)$/i.test(this._options.verticalPosition) ? a = 200 : /^(middle|center)$/i.test(this._options.verticalPosition) ? a = this._height / 2 : /^(bottom|max)$/i.test(this._options.verticalPosition) && (a = this._height - n);\n            for (var r = [], l = new b(e, a), c = new b(e, a), _ = null, p = Math.round(u(0, 360)), d = 0; !(i <= 0);) {\n                if (i--,\n                    s = Math.round((1 * Math.random() - .2) * this._options.horizontalSpeed),\n                    h = Math.round((1 * Math.random() - .5) * (.25 * this._height)),\n                    (_ = new b).copy(c),\n                    \"right\" === t) {\n                    if (_.add(s, h),\n                        c.x >= o)\n                        break\n                } else if (\"left\" === t && (_.subtract(s, h),\n                    c.x <= -200))\n                    break;\n                r.push({\n                    point1: new b(l.x, l.y),\n                    point2: new b(c.x, c.y),\n                    point3: _,\n                    color: p,\n                    delay: d,\n                    dir: t,\n                    alpha: 0,\n                    phase: 0\n                }),\n                    l.copy(c),\n                    c.copy(_),\n                    d += 4,\n                    p += this._options.colorCycleSpeed\n            }\n            this._ribbons.push(r)\n        },\n        _drawRibbonSection: function (t) {\n            if (t) {\n                if (1 <= t.phase && t.alpha <= 0)\n                    return !0;\n                if (t.delay <= 0) {\n                    if (t.phase += .02,\n                        t.alpha = 1 * Math.sin(t.phase),\n                        t.alpha = t.alpha <= 0 ? 0 : t.alpha,\n                        t.alpha = 1 <= t.alpha ? 1 : t.alpha,\n                        this._options.animateSections) {\n                        var i = .1 * Math.sin(1 + t.phase * Math.PI / 2);\n                        \"right\" === t.dir ? (t.point1.add(i, 0),\n                            t.point2.add(i, 0),\n                            t.point3.add(i, 0)) : (t.point1.subtract(i, 0),\n                                t.point2.subtract(i, 0),\n                                t.point3.subtract(i, 0)),\n                            t.point1.add(0, i),\n                            t.point2.add(0, i),\n                            t.point3.add(0, i)\n                    }\n                } else\n                    t.delay -= .5;\n                var n = this._options.colorSaturation\n                    , o = this._options.colorBrightness\n                    , s = \"hsla(\" + t.color + \", \" + n + \", \" + o + \", \" + t.alpha + \" )\";\n                this._context.save(),\n                    0 !== this._options.parallaxAmount && this._context.translate(0, this._scroll * this._options.parallaxAmount),\n                    this._context.beginPath(),\n                    this._context.moveTo(t.point1.x, t.point1.y),\n                    this._context.lineTo(t.point2.x, t.point2.y),\n                    this._context.lineTo(t.point3.x, t.point3.y),\n                    this._context.fillStyle = s,\n                    this._context.fill(),\n                    0 < this._options.strokeSize && (this._context.lineWidth = this._options.strokeSize,\n                        this._context.strokeStyle = s,\n                        this._context.lineCap = \"round\",\n                        this._context.stroke()),\n                    this._context.restore()\n            }\n            return !1\n        },\n        _onDraw: function () {\n            for (var t = 0, i = this._ribbons.length; t < i; ++t)\n                this._ribbons[t] || this._ribbons.splice(t, 1);\n            this._context.clearRect(0, 0, this._width, this._height);\n            for (var n = 0; n < this._ribbons.length; ++n) {\n                for (var o = this._ribbons[n], s = o.length, h = 0, e = 0; e < s; ++e)\n                    this._drawRibbonSection(o[e]) && h++;\n                s <= h && (this._ribbons[n] = null)\n            }\n            this._ribbons.length < this._options.ribbonCount && this.addRibbon(),\n                requestAnimationFrame(this._onDraw)\n        },\n        _onResize: function (t) {\n            var i = n();\n            this._width = i.width,\n                this._height = i.height,\n                this._canvas && (this._canvas.width = this._width,\n                    this._canvas.height = this._height,\n                    this._context && (this._context.globalAlpha = this._options.colorAlpha))\n        },\n        _onScroll: function (t) {\n            var i = n();\n            this._scroll = i.scrolly\n        }\n    },\n        t\n}()),\n    new Ribbons({\n        animateSections: true,\n        colorAlpha: 0.5,\n        colorBrightness: \"50%\",\n        colorCycleSpeed: 5,\n        colorSaturation: \"60%\",\n        horizontalSpeed: 200,\n        parallaxAmount: -0.2,\n        ribbonCount: 3,\n        strokeSize: 0,\n        verticalPosition: \"random\"\n    });","import App from './App.svelte';\nimport type { SvelteComponent } from 'svelte';  // TS \n\nconst app: SvelteComponent = new App({\n    target: document.getElementById('app') as HTMLElement  // \n});\n\nexport default app;"],"names":["noop","assign","tar","src","k","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","action_destroyer","action_result","destroy","append","target","node","appendChild","append_styles","style_sheet_id","styles","append_styles_to","document","root","getRootNode","ownerDocument","host","get_root_for_style","getElementById","style","element","id","textContent","head","sheet","append_stylesheet","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","name","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","prevent_default","preventDefault","call","this","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","toggle_class","toggle","classList","construct_svelte_component","component","props","current_component","set_current_component","get_current_component","Error","onMount","$$","on_mount","push","createEventDispatcher","type","detail","cancelable","callbacks","bubbles","CustomEvent","custom_event","slice","defaultPrevented","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","schedule_update","then","flush","add_render_callback","seen_callbacks","Set","flushidx","saved_component","update","e","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","ensure_array_like","array_like_or_iterator","undefined","Array","from","get_spread_update","levels","updates","to_null_out","accounted_for","$$scope","n","key","get_spread_object","spread_props","create_component","mount_component","m","new_on_destroy","map","filter","on_destroy","destroy_component","filtered","targets","indexOf","flush_render_callbacks","init","instance","create_fragment","not_equal","parent_component","bound","on_disconnect","context","Map","skip_bound","ready","ret","rest","fill","make_dirty","hydrate","nodes","childNodes","children","l","intro","SvelteComponent","$$set","$destroy","$on","index","splice","$set","obj","keys","window","__svelte","v","css","ref","insertAt","getElementsByTagName","firstChild","styleSheet","cssText","subscriber_queue","readable","start","subscribe","writable","stop","subscribers","set","new_value","run_queue","subscriber","invalidate","size","derived","stores","initial_value","single","isArray","stores_array","every","Boolean","auto","started","values","pending","cleanup","sync","result","unsubscribers","store","unsub","unsubscribe","switch_instance_spread_levels","params","getLocation","hashPosition","location","href","substr","qsPosition","querystring","loc","_loc","link","opts","linkOpts","tagName","toLowerCase","updateLink","updated","charAt","disabled","history","replaceState","state","__svelte_spa_router_scrollX","scrollX","__svelte_spa_router_scrollY","scrollY","hash","scrollstateHistoryHandler","currentTarget","val","routes","$$props","prefix","restoreScrollState","RouteItem","constructor","path","_sveltesparouter","RegExp","pattern","str","tmp","ext","arr","split","shift","substring","parse","conditions","userData","_pattern","_keys","match","startsWith","matches","exec","out","decodeURIComponent","checkConditions","routesList","route","componentParams","dispatch","dispatchNextTick","previousScrollState","popStateChanged","scrollTo","lastLoc","componentObj","unsubscribeLoc","newLoc","$$invalidate","loading","loadingParams","loaded","default","onDestroy","scrollRestoration","header","div","a0","nav","ul","li0","li1","a2","li2","a3","footer","a1","DUMMY_KEY","supabase","url","token","table","self","query","selectCols","orders","limit","offset","filters","body","fetchRequest","async","method","prefer","URLSearchParams","orderStr","column","ascending","join","toString","f","op","operator","endsWith","buildUrl","headers","Authorization","apikey","res","fetch","includes","JSON","stringify","ok","errorText","errorJson","message","error","status","statusText","count","responseText","parseInt","get","select","columns","returning","order","range","to","eq","neq","gt","gte","lt","lte","like","ilike","entries","col","pad2","String","padStart","formatTime","time","date","Date","getFullYear","getMonth","getDate","formatDate2","toLocaleDateString","toLocaleTimeString","create_if_block","diago","t0_value","title","t2_value","t5_value","readTime","t8_value","excerpt","a0_href_value","a1_href_value","article","h2","span0","span1","t0","t2","t5","t8","if_block0","create_if_block_2","each_value","func","if_block1","create_if_block_1","li","t","t_value","if_block","main","div1","div0","_","posts","currentPage","totalPages","getData","page","console","warn","content","goToPage","totalData","totalError","Math","ceil","div6","log","h1","Number","raw_value","button","p0","p1","goback","innerHTML","post","newReadTime","dataup","errorup","div2","Ribbons","h","documentElement","u","arguments","round","random","max","innerWidth","clientWidth","innerHeight","clientHeight","width","height","ratio","centerx","centery","scrollx","pageXOffset","scrollLeft","clientLeft","scrolly","pageYOffset","scrollTop","clientTop","x","y","prototype","copy","multiply","divide","subtract","clampX","min","clampY","flipX","flipY","_canvas","_context","_sto","_width","_height","_scroll","_ribbons","_options","colorSaturation","colorBrightness","colorAlpha","colorCycleSpeed","verticalPosition","horizontalSpeed","ribbonCount","strokeSize","parallaxAmount","animateSections","_onDraw","bind","_onResize","_onScroll","setOptions","hasOwnProperty","display","position","margin","padding","border","outline","left","top","right","bottom","getContext","clearRect","globalAlpha","addRibbon","s","test","point1","point2","point3","color","delay","dir","alpha","phase","_drawRibbonSection","sin","PI","save","translate","beginPath","moveTo","lineTo","fillStyle","lineWidth","strokeStyle","lineCap","stroke","restore","requestAnimationFrame"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}